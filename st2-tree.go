package mcfile

import (
	"io"
	"os"
	"github.com/fbaube/gtoken"
	"github.com/fbaube/gtree"
	L "github.com/fbaube/mlog"
	SU "github.com/fbaube/stringutils"
)

// st2_Tree takes the output of st1_Read - which at a minimum is
// a complete set of `GToken`s - and creates a `GTree`. Note that
// st1_Read might have already generated a CST (Concrete Syntax
// Tree) (MKDN and HTML do this) but in such cases, st1_Read
// also prepared the list of corresponding `GToken`s.
// Summary:
// - 2a PrepareToTree() // make GTags := GTokens
// - 2b BuildIntoTree() // make GTree := GTags
// - 2c PostTreeMeta()  // process DOCTYPE ?
// - 2d NormalizeTree() // convert a tree from a 3P-lib
// .
func (p *Contentity) st2_Tree() *Contentity {
	if p.HasError() {
		return p
	}
	p.logStg = "22"
	p.L(LDebug, "=== 22:Tree ===")
	ret := p.
		st2a_PrepareToTree().
		st2b_BuildIntoTree().
		st2c_PostTreeMeta().
		st2d_NormalizeTree()
	if !p.HasError() { p.L(LOkay, "=== 22:Tree: Success ===") }
	return ret
}

// st2a_PrepareToTree is used when there is some preparation
// specific to building the tree, such as making GTags out
// of a slice of GTokens.
// .
func (p *Contentity) st2a_PrepareToTree() *Contentity {
	if p.HasError() {
		return p
	}
	p.logStg = "2a"
	var e error
	switch p.MarkupType() {
	case SU.MU_type_XML:
		p.GTags, e = gtree.MakeGTagsFromGTokens(p.GTokens)
		if e != nil {
			p.WrapError("can't make gtags from xml gtokens", e)
			return p
		}
	case SU.MU_type_MKDN:
		p.GTags, e = gtree.MakeGTagsFromGTokens(p.GTokens)
		if e != nil {
			p.WrapError("can't make gtags from mkdn gtokens", e)
			return p
		}
	case SU.MU_type_HTML:
		p.GTags, e = gtree.MakeGTagsFromGTokens(p.GTokens)
		if e != nil {
			p.WrapError("can't make gtags from html gtokens", e)
			return p
		}
	}
	return p
}

// st2b_BuildIntoTree assembles the slice of `GTag`s into a `GTree`.
// .
func (p *Contentity) st2b_BuildIntoTree() *Contentity {
	if p.HasError() {
		return p
	}
	var e error
	p.GTree, e = gtree.NewGTreeFromGTags(p.GTags)
	if e != nil {
		println("==> mcfl.st2b: Error!:", e.Error())
		p.WrapError("NewGTreeFromGTags", e)
		return p
	}
	if p.GTree == nil {
		println("==> mcfl.st2b: got nil Gtree: %s", e.Error())
		p.WrapError("nil tree from NewGTreeFromGTags", e)
	}
	if p.GTree != nil && p.GTreeWriter != nil &&
		p.GTreeWriter != io.Discard {
		gtoken.DumpTo(p.GTokens, p.GTreeWriter)
	} else {
		gtoken.DumpTo(p.GTokens, os.Stdout)
	}
	return p
}

// PostTreeMeta is used to process metadata that
// is best handled only after tree-building.
// .
func (p *Contentity) st2c_PostTreeMeta() *Contentity {
	if p.HasError() {
		return p
	}
	switch p.MarkupType() {
	case SU.MU_type_XML:
		L.L.Warning("TODO> st2c_PostTreeMeta XML")
	case SU.MU_type_MKDN:
		L.L.Warning("TODO> st2c_PostTreeMeta MKDN")
	case SU.MU_type_HTML:
		L.L.Warning("TODO> st2c_PostTreeMeta HTML")
	}
	return p
}

// NormalizeTree is used when we have a tree that is generated by a
// library, and which therefore must still be converted into a `GTree`.
//
// It is also used to normalize XML, by resolving entities etc. This
// is part of the XML process of canonicalization.
// .
func (p *Contentity) st2d_NormalizeTree() *Contentity {
	if p.HasError() {
		return p
	}
	switch p.MarkupType() {
	case SU.MU_type_XML:
		L.L.Warning("TODO> 2d. NormalizeTree XML ==> ENTs, etc.!")
		/* code to use !
		e = p.DoEntitiesList()
		if e != nil {
			return errors.Wrap(e, "DoEntitiesList")
		}
		e = p.SubstituteEntities()
		if e != nil {
			return errors.Wrap(e, "SubstituteEntities")
		}
		*/
	case SU.MU_type_MKDN:
		// L.L.Warning("TODO> 2d. NormalizeTree MKDN")
	case SU.MU_type_HTML:
		// L.L.Warning("TODO> 2d. NormalizeTree HTML")
	}
	return p
}
