package mcfile

import (
	"os"

	// "fmt"
	"github.com/fbaube/gtoken"
	"github.com/fbaube/gtree"
	L "github.com/fbaube/mlog"
)

// st2_Tree takes the output of st1_Read - which at a minimum
// is a complete set of `GToken`s - and creates a `GTree`.
// Note that st1_Read might have already generated a CST
// (MKDN and HTML do this) but in such cases, st1_Read
// also prepared the list of corresponding `GToken`s.
// - PrepareToTree() // e.g. GTags
// - ParseIntoTree()
// - PostTreeMeta()
// - NormalizeTree()
//
func (p *Contentity) st2_Tree() *Contentity {
	if p.HasError() {
		return p
	}
	p.logStg = "22"
	p.L(LProgress, "22:Tree")
	return p.
		st2a_PrepareToTree().
		st2b_ParseIntoTree().
		st2c_PostTreeMeta().
		st2d_NormalizeTree()
}

// st2a_PrepareToTree is used when there is some preparation
// specific to building the tree, such as making GTags out
// of a bunch of GTokens.
//
func (p *Contentity) st2a_PrepareToTree() *Contentity {
	if p.HasError() {
		return p
	}
	p.logStg = "2a"
	var e error
	switch p.FileType() {
	case "XML":
		p.GTags, e = gtree.MakeGTagsFromGTokens(p.GTokens)
		if e != nil {
			p.WrapError("can't make gtags from xml", e)
			return p
		}
	case "MKDN":
		p.GTags, e = gtree.MakeGTagsFromGTokens(p.GTokens)
		if e != nil {
			p.WrapError("can't make gtags from mkdn", e)
			return p
		}
	case "HTML":
		p.GTags, e = gtree.MakeGTagsFromGTokens(p.GTokens)
		if e != nil {
			p.WrapError("can't make gtags from html", e)
			return p
		}
	}
	return p
}

// ParseIntoTree is Step 2b.
//
func (p *Contentity) st2b_ParseIntoTree() *Contentity {
	if p.HasError() {
		return p
	}
	var e error
	p.GTree, e = gtree.NewGTreeFromGTags(p.GTags)
	if e != nil {
		println("==> mcfl.st2b: Error!:", e.Error())
		p.WrapError("NewGTreeFromGTags", e)
		return p
	}
	if p.GTree == nil {
		println("==> mcfl.st2b: got nil Gtree: %s", e.Error())
		p.WrapError("nil tree from NewGTreeFromGTags", e)
	}
	if p.GTree != nil && p.GTreeWriter != nil {
		gtoken.DumpTo(p.GTokens, p.GTreeWriter)
	} else {
		gtoken.DumpTo(p.GTokens, os.Stdout)
	}
	return p
}

// PostTreeMeta is used to process metadata that is best handled
// only after tree-building. For example, XML `DOCTYPE`.
//
func (p *Contentity) st2c_PostTreeMeta() *Contentity {
	if p.HasError() {
		return p
	}
	switch p.FileType() {
	case "XML":
		L.L.Warning("TODO?> st2c_PostTreeMeta XML")
		/*
			// =========================
			//   XML ANALYSIS and also
			//    BTW get the DOCTYPE
			// =========================
			pX.GTokens = gparse.XmlCheckForPreambleToken(pX.GTokens)
			e = p.ProcessMetaGetDoctype()
			if e != nil {
				return errors.Wrap(e, "ProcessMetaGetDoctype")
			}

				// println("\t Got XFM/DT:", pGF.XmlFileMeta.String())
				if pX.DoctypeIsDeclared {
					e = SetMtypeUsingDeclaredDoctype(p)
					if e != nil {
						return errors.Wrap(e, "SetMtypeUsingDeclaredDoctype")
					}
					// FIXME!! println("    --> Declared DOCTYPE:", pX.String())
				}
				e = p.RefineDirectives()
				if e != nil {
					return errors.Wrap(e, "RefineDirectives")
				}
		*/
	case "MKDN":
		L.L.Warning("TODO> st2c_PostTreeMeta MKDN")
	case "HTML":
		L.L.Warning("TODO> st2c_PostTreeMeta HTML")
	}
	return p
}

// NormalizeTree is used when we have a tree that is generated by a
// library, and which therefore must still be converted into a `GTree`.
//
func (p *Contentity) st2d_NormalizeTree() *Contentity {
	if p.HasError() {
		return p
	}
	switch p.FileType() {
	case "XML":
		L.L.Warning("TODO> 2d. NormalizeTree XML ==> ENTs, etc.!")
		/*
			e = p.DoEntitiesList()
			if e != nil {
				return errors.Wrap(e, "DoEntitiesList")
			}
			e = p.SubstituteEntities()
			if e != nil {
				return errors.Wrap(e, "SubstituteEntities")
			}
		*/
	case "MKDN":
		L.L.Warning("TODO> 2d. NormalizeTree MKDN")
	case "HTML":
		L.L.Warning("TODO> 2d. NormalizeTree HTML")
	}
	return p
}
