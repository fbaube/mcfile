package mcfile

import (
	"fmt"
	"os"

	// "fmt"
	"github.com/fbaube/gtoken"
	"github.com/fbaube/gtree"
	L "github.com/fbaube/mlog"
)

// st2_Tree takes the output of st1_Read - which at a minimum
// is a complete set of `GToken`s - and creates a `GTree`.
// Note that st1_Read might have generated a CST (MKDN and
// HTML do this) but in such cases, st1_Read also prepared
// the list of corresponding `GToken`s.
// - PrepareToTree() // e.g. GTags
// - ParseIntoTree()
// - PostTreeMeta()
// - NormalizeTree()
//
func (p *Contentity) st2_Tree() *Contentity {
	if p.HasError() {
		return p
	}
	p.logStg = "22"
	p.L(LProgress, "Tree")
	return p.
		st2a_PrepareToTree().
		st2b_ParseIntoTree().
		st2c_PostTreeMeta().
		st2d_NormalizeTree()
}

// st2a_PrepareToTree is Step 2a:
// Used when there is some preparation specific to building
// the tree. Like making GTags out of a bunch of GTokens.
//
func (p *Contentity) st2a_PrepareToTree() *Contentity {
	if p.HasError() {
		return p
	}
	p.logStg = "2a"
	var e error
	switch p.FileType() {
	case "XML":
		p.GTags, e = gtree.MakeGTagsFromGTokens(p.GTokens)
		if e != nil {
			p.Err = fmt.Errorf("st2a gtree: can't make gtags from xml: %w", e)
			return p
		}
	case "MKDN":
		p.GTags, e = gtree.MakeGTagsFromGTokens(p.GTokens)
		if e != nil {
			p.Err = fmt.Errorf("st2a gtree: can't make gtags from mkdn: %w", e)
			return p
		}
	case "HTML":
		p.GTags, e = gtree.MakeGTagsFromGTokens(p.GTokens)
		if e != nil {
			p.Err = fmt.Errorf("st2a gtree: can't make gtags from html: %w", e)
			return p
		}
	}
	return p
}

// ParseIntoTree is Step 2b.
//
func (p *Contentity) st2b_ParseIntoTree() *Contentity {
	if p.HasError() {
		return p
	}
	var e error
	p.GTree, e = gtree.NewGTreeFromGTags(p.GTags)
	if e != nil {
		p.Err = e
		println("==> mcfl.st2b: Error!:", e)
		return p
	}
	if p.GTree == nil {
		println("==> mcfl.st2b: got nil Gtree: %s", e.Error())
	}
	if p.GTree != nil && p.GTreeOutput != nil {
		gtoken.DumpTo(p.GTokens, p.GTreeOutput)
	} else {
		gtoken.DumpTo(p.GTokens, os.Stdout)
	}
	return p
}

// PostTreeMeta is Step 2c. <br/>
// This is used to process metadata that is best handled
// only after tree-building. For example, XML `DOCTYPE`.
//
func (p *Contentity) st2c_PostTreeMeta() *Contentity {
	if p.HasError() {
		return p
	}
	switch p.FileType() {
	case "XML":
		L.L.Warning("TODO> st2c_PostTreeMeta XML ==> BIG!")
		/*
			// =========================
			//   XML ANALYSIS and also
			//    BTW get the DOCTYPE
			// =========================
			pX.GTokens = gparse.XmlCheckForPreambleToken(pX.GTokens)
			e = p.ProcessMetaGetDoctype()
			if e != nil {
				return errors.Wrap(e, "ProcessMetaGetDoctype")
			}

				// println("\t Got XFM/DT:", pGF.XmlFileMeta.String())
				if pX.DoctypeIsDeclared {
					e = SetMtypeUsingDeclaredDoctype(p)
					if e != nil {
						return errors.Wrap(e, "SetMtypeUsingDeclaredDoctype")
					}
					// FIXME!! println("    --> Declared DOCTYPE:", pX.String())
				}
				e = p.RefineDirectives()
				if e != nil {
					return errors.Wrap(e, "RefineDirectives")
				}
		*/
	case "MKDN":
		L.L.Warning("TODO> st2c_PostTreeMeta MKDN")
	case "HTML":
		L.L.Warning("TODO> st2c_PostTreeMeta HTML")
	}
	return p
}

// NormalizeTree is Step 2d. <br/>
// This is used when we have a tree that is generated by a library,
// and which therefore must still be converted into a `GTree`.
//
func (p *Contentity) st2d_NormalizeTree() *Contentity {
	if p.HasError() {
		return p
	}
	switch p.FileType() {
	case "XML":
		L.L.Warning("TODO> 2d. NormalizeTree XML ==> ENTs, etc.!")
		/*
			e = p.DoEntitiesList()
			if e != nil {
				return errors.Wrap(e, "DoEntitiesList")
			}
			e = p.SubstituteEntities()
			if e != nil {
				return errors.Wrap(e, "SubstituteEntities")
			}
		*/
	case "MKDN":
		L.L.Warning("TODO> 2d. NormalizeTree MKDN")
	case "HTML":
		L.L.Warning("TODO> 2d. NormalizeTree HTML")
	}
	return p
}
